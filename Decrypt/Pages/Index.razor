@page "/"
@using System.Text.Json
@using Decrypt.Model.Facebook
@using System.IO.Compression
@using Decrypt.Model.Facebook.Converters
@using Decrypt.Model.Shared.Interfaces
@using Decrypt.Services

@inject DataService _dataService
@inject DialogService _dialogService

<PageTitle>Home</PageTitle>

<h1>Load in zip files</h1>
<div class="my-3">
	<InputFile label="file_upload" title="file_upload" OnChange="@LoadFiles" accept=".zip"/>
</div>
<div class="my-3">
	<h3>Download Links:</h3>
	<a href="https://www.facebook.com/dyi/?referrer=ayi" target="_blank">Download your Facebook Data</a>
</div>

<div>@_generationDate</div>

@code {

	private readonly Dictionary<string, Type> _availableFileWrappers = new()
	{
		{ AdvertisersUsingYourActivity.Filepath, typeof(AdvertisersUsingYourActivity) }, 
		{ AdvertiserYouInteractedWith.Filepath, typeof(AdvertiserYouInteractedWith) },
		{ InferredTopics.Filepath, typeof(InferredTopics)}
	};

	private const long MaxFileSize = 4294967296; // 4 GB

	private DateTimeOffset? _generationDate;
	private async Task LoadFiles(InputFileChangeEventArgs e)
	{

		var options = new JsonSerializerOptions();
		options.Converters.Add(new FbConverter());

		//TODO: figure out a better way to do this
		await using var stream = new MemoryStream();
		await e.File.OpenReadStream(MaxFileSize).CopyToAsync(stream);
		_generationDate = e.File.LastModified;
		using var archive = new ZipArchive(stream);
		foreach (var entry in archive.Entries)
		{
			if (!_availableFileWrappers.TryGetValue(entry.FullName, out var wrapperType)) continue;
			var unzippedEntryStream = entry.Open();
			_dataService.FbRoot ??= new FbRoot();

			if (await JsonSerializer.DeserializeAsync(unzippedEntryStream, wrapperType, options) is IFileWrapper wrapperObj)
			{
				_dataService.FbRoot.AvailableData.TryAdd(wrapperType.Name, wrapperObj);
			}
		}
	}
}